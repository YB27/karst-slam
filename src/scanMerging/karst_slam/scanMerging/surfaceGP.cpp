#include "karst_slam/scanMerging/surfaceGP.h"
#include "karst_slam/scanMerging/dataForScanMerging.h"
#include <mrpt/poses/CPoint3D.h>
#include <mrpt/math/lightweight_geom_data.h>
#include <mrpt/utils/CConfigFile.h>
#include <cmath>

using namespace std;
using namespace mrpt::poses;
using namespace mrpt::utils;
using namespace karst_slam::scanMerging;

surfaceGP::surfaceGP(const CConfigFile& cfg)
{
    m_kernelParams.type_s          = cfg.read_string("GaussianProcess", "kernel_s"              , "", true);
    m_kernelParams.type_yaw        = cfg.read_string("GaussianProcess", "kernel_yaw"            , "", true);
    m_kernelParams.lengthscale_s   = cfg.read_double("GaussianProcess", "lengthscale_s"         , 0.05, true);
    m_kernelParams.lengthscale_yaw = cfg.read_double("GaussianProcess", "lengthscale_yaw"       , 0.5, true);
    m_kernelParams.variance        = cfg.read_double("GaussianProcess", "kernel_variance"       , 1., true);

    m_pythonScriptFile             = cfg.read_string("GaussianProcess", "pythonScript"          , "", true);
    m_processNoise                 = cfg.read_double("GaussianProcess", "kernel_process_variance",1., true);
    m_batchSize                    = cfg.read_int("GaussianProcess", "batch_size", 10000, true);
    m_useOffRangePts               = cfg.read_bool("GaussianProcess", "useOffRangePtsAsCensoredData", false, true);

    m_dataFolder                   = cfg.read_string("General"   , "dataFolder" , "" ,true);
    m_loadSurfaceData              = cfg.read_bool("General", "loadSurfaceData", true, true);

    this->setMinLoggingLevel(mrpt::utils::LVL_DEBUG);
}

scanMergingResults surfaceGP::estimateDistributions(const shared_ptr<dataForScanMerging>& data)
{
    // Clear previous data
    m_surfaceData.clear();

    // Execute a python script using GPy to train a GP to learn the surface generated by the training data (vertical sonar)
    // Then use it to estimate the more likely theta for the horizontal sonar measurement (validation data)
    string command = "python " + m_pythonScriptFile + " " + m_kernelParams.type_s + " "
                                                    + m_kernelParams.type_yaw + " "
                                                    + to_string(m_kernelParams.variance) + " "
                                                    + to_string(m_kernelParams.lengthscale_s) + " "
                                                    + to_string(m_kernelParams.lengthscale_yaw) + " "
                                                    + to_string(m_processNoise) + " "
                                                    + to_string(m_batchSize) + " "
                                                    + m_dataFolder + " "
                                                    + to_string(m_isLearningMeanFunc ? 1 : 0) + " "  
                                                    + to_string(m_useOffRangePts ? 1 : 0);
    MRPT_LOG_DEBUG_STREAM("[surfaceGP::estimateDistributions] Command : " << command);
    system(command.c_str());

    // Only used for sliced graphs (used in the journal of Sensors paper) 
    // Should stay commented
    //addPriorToSlicesData(curvilinearAbscissaPoseMap,
    //                     sonarPoseOnRobot,
    //                     priorCylinder);

    // Load the results
    // TODO : Set the files in the .ini file
    scanMergingResults res;
    if(m_loadSurfaceData)
        loadSurfaceGP(m_dataFolder + "/res_estimatedSurface.txt",
                      data->bodyPoses,
                      data->verticalSonarPoseOnRobot,
                      data->priorCylinder);

    loadDistribution(m_dataFolder + "/res_distributionBeta.txt",
                     res.distribution);

    loadNormals(m_dataFolder + "/res_estimatedNormalsNew.txt",
                m_dataFolder + "/debugNormals.txt",
                data->verticalSonarPoseOnRobot,
                m_surfaceData.normals);

    res.surfaceGPData = m_surfaceData;

    return res;
}

scanMergingResults surfaceGP::estimateDistributions(const map<uint64_t, trajectoryPose<CPose3DPDFGaussian>>& bodyPoses,
                                                    const CPose3D& verticalSonarPoseOnRobot,
                                                    const ellipticCylinder& priorCylinder)
{
    // Clear previous data
    m_surfaceData.clear();

    // Execute a python script using GPy to train a GP to learn the surface generated by the training data (vertical sonar)
    // Then use it to estimate the more likely theta for the horizontal sonar measurement (validation data)
    string command = "python " + m_pythonScriptFile + " " + m_kernelParams.type_s + " "
                                                    + m_kernelParams.type_yaw + " "
                                                    + to_string(m_kernelParams.variance) + " "
                                                    + to_string(m_kernelParams.lengthscale_s) + " "
                                                    + to_string(m_kernelParams.lengthscale_yaw) + " "
                                                    + to_string(m_processNoise) + " "
                                                    + to_string(m_batchSize) + " "
                                                    + m_dataFolder + " "
                                                    + to_string(m_isLearningMeanFunc ? 1 : 0) + " "
                                                    + to_string(m_useOffRangePts ? 1 : 0);
    MRPT_LOG_DEBUG_STREAM("[surfaceGP::estimateDistributions] Command : " << command);
    system(command.c_str());

    // Only used for sliced graphs (used in the journal of Sensors paper)
    //addPriorToSlicesData(curvilinearAbscissaPoseMap,
    //                     sonarPoseOnRobot,
    //                     priorCylinder);

    scanMergingResults res;
    // Load the results
    // TODO : Set the files in the .ini file
    if(m_loadSurfaceData)
        loadSurfaceGP(m_dataFolder + "/res_estimatedSurface.txt",
                      bodyPoses,
                      verticalSonarPoseOnRobot,
                      priorCylinder);

    loadDistribution(m_dataFolder + "/res_distributionBeta.txt",
                     res.distribution);

    loadNormals(m_dataFolder + "/res_estimatedNormalsNew.txt",
                m_dataFolder + "/debugNormals.txt",
                verticalSonarPoseOnRobot,
                m_surfaceData.normals);

    res.surfaceGPData = m_surfaceData;

    return res;
}


void surfaceGP::loadSurfaceGP(const string &fileName,
                              const map<uint64_t, trajectoryPose<CPose3DPDFGaussian>>& bodyPoses,
                              const CPose3D &sonarPoseOnRobot,
                              const ellipticCylinder& priorCylinder)
{
    CPose3D globalPoseSonar;
    mrpt::math::TPoint3D pt_mean_loc, pt_low_loc, pt_up_loc,
                         pt_mean_glob, pt_low_glob, pt_up_glob;
    pt_mean_loc[2] = pt_low_loc[2] = pt_up_loc[2] = 0.; // Observations are in the plane XY
    double cy, sy;

    double r_prior, s, yaw, mean_r, low_r, up_r;
    unsigned long long ts;
    const Eigen::Matrix3d& cylinderBase   = priorCylinder.getPrincipalBase();
    const Eigen::Vector3d& cylinderCenter = priorCylinder.getCenter();
    ifstream f(fileName);
    if(f.is_open())
    {
        string line;
        while(getline(f,line))
        {
            stringstream ss(line);
            string val;

            // timeStamp
            getline(ss,val,',');
            ts = stoull(val);

            // s
            getline(ss,val,',');
            s = stod(val);

            // yaw
            getline(ss,val,',');
            yaw = stod(val);
            cy = cos(yaw);
            sy = sin(yaw);

            // Mean, Mean - 3*sigma, Mean + 3*sigma of estimated rho^v
            // Use try/cache as for near zero value expressed in scientific notation (eg. x.xxe-308), stod can fail !   
            getline(ss,val,',');
            try{
                mean_r = stod(val);
            }
            catch(const std::out_of_range& e)
            {
                mean_r = 0;
            }
            getline(ss,val,',');
            try{
                low_r = stod(val);
            }
            catch(const std::out_of_range& e)
            {
                low_r = 0;
            }
            getline(ss,val,',');
            try{
                up_r = stod(val);
            }
            catch(const std::out_of_range& e)
            {
                up_r = 0;
            }

            Eigen::Vector3d ptOnGuide = s*cylinderBase.col(0) + cylinderCenter,
                                dir   = cy*cylinderBase.col(1) + sy*cylinderBase.col(2);

            if(!m_isLearningMeanFunc)
            {
                r_prior = priorCylinder.getDistanceToInfiniteCylinderAlongDirection(ptOnGuide, dir);

                r_prior = rangeMapping::rangeMap(r_prior);
                mean_r += r_prior;
                low_r  += r_prior;
                up_r   += r_prior;
            }
            
            mean_r = rangeMapping::inverseRangeMap(mean_r);
            low_r  = rangeMapping::inverseRangeMap(low_r);
            up_r   = rangeMapping::inverseRangeMap(up_r);

            Eigen::Vector3d mean_point_local, low_point_local, up_point_local;
            mean_point_local << 0., mean_r*cy, mean_r*sy;
            low_point_local  << 0., low_r*cy , low_r*sy;
            up_point_local   << 0., up_r*cy  , up_r*sy;

            Eigen::Vector3d mean_point_glob = ptOnGuide + cylinderBase*mean_point_local, 
                            low_point_glob  = ptOnGuide + cylinderBase*low_point_local,
                            up_point_glob   = ptOnGuide + cylinderBase*up_point_local;
            m_surfaceData.meanPoints.push_back(CPoint3D(mean_point_glob));
            m_surfaceData.lowBoundPoints.push_back(CPoint3D(low_point_glob));
            m_surfaceData.highBoundPoints.push_back(CPoint3D(up_point_glob));
        }

        f.close();
    }
    else
        MRPT_LOG_ERROR_STREAM("[surfaceGP::loadSurfaceGP] Can't open file " << fileName);

    cout << "Finish loadSurface" << endl;
}

void surfaceGP::loadDistribution(const string& fileName,
                                 map<int, vector<distributionTheta>>& distribution)
{
    ifstream f(fileName);
    if(f.is_open())
    {
        string line;
        int pt_idx, theta_idx;
        double alpha, beta;
        while(getline(f,line))
        {
            stringstream ss(line);
            string val;

            // pt_idx
            getline(ss,val,',');
            pt_idx = stoi(val);

            // theta_idx
            getline(ss,val,',');
            theta_idx = stoi(val);

            // alpha
            getline(ss,val,',');
            alpha = stod(val);

            // beta
            getline(ss,val,',');
            beta = stod(val);

            distribution[pt_idx].push_back(distributionTheta(theta_idx, alpha, beta));
        }
    }
}

void surfaceGP::loadNormals(const string& fileName,
                            const string& fileDebugName,
                            const CPose3D& verticalSonarPose,
                            vector<CPointPDFGaussian>& normals)
{
    ifstream file(fileName);
    if(file.is_open())
    {
        string line, val;
        getline(file,line); // ignore header
        while(getline(file,line))
        {
            stringstream ss(line);

            CPointPDFGaussian normal;

            // Normal mean
            for(int i = 0; i < 3; i++)
            {
                getline(ss,val,',');
                normal.mean.m_coords[i] = stod(val);
            }

            // Normal cov
            for(int i = 0; i < 3; i++)
            {
                for(int j = 0; j < 3; j++)
                {
                    getline(ss,val,',');
                    normal.cov(i,j) = stod(val);
                }
            }
            normals.push_back(normal);
        }
        file.close();
    }
    else
        MRPT_LOG_ERROR_STREAM("[surfaceGP::loadNormals] Failed to open the file : " << fileName);

    // Load debug file with points used to compute the normal
    ifstream fileDebug(fileDebugName);
    if(fileDebug.is_open())
    {
        string line;
        double x,y,z;
        while(getline(fileDebug,line))
        {
            stringstream ss(line);
            string val;

            // x
            getline(ss,val,',');
            x = stod(val);

            // y
            getline(ss,val,',');
            y = stod(val);

            // z
            getline(ss,val,',');
            z = stod(val);

            m_surfaceData.pointsForNormals_debug.push_back(mrpt::math::TPoint3D(x,y,z));
        }

        fileDebug.close();
    }
    else
        cout << "Failed to open the file : " << fileDebugName << endl;
}

void surfaceGP::addPriorToSlicesData(const map<int, CPose3D>& curvilinearAbscissaPoseMap,
                                     const CPose3D &sonarPoseOnRobot,
                                     const ellipticCylinder& priorCylinder)
{
    MRPT_LOG_INFO_STREAM("[surfaceGP::addPriorToSlicesData] Add prior to the slices data ...");
    vector<string> planeSlices = {"XY", "XZ", "ZY"};

    string folder = "/home/yohan/pid-workspace/packages/karst_slam/share/resources/SlicesData/";
    string subfolder = m_kernelParams.type_s + "_" + m_kernelParams.type_yaw;
    MRPT_LOG_INFO_STREAM("[surfaceGP::addPriorToSlicesData] Folder : " << folder);

    MRPT_LOG_INFO_STREAM("[surfaceGP::addPriorToSlicesData] SubFolder : " << subfolder);

    // Modify the slice files generated by the python script by adding the r_prior
    for(const string& slice : planeSlices)
    {
        string file = folder + subfolder + "/" + slice + "slice.txt";
        MRPT_LOG_INFO_STREAM("[surfaceGP::addPriorToSlicesData] Slice file : " << file);
        addPriorToSliceFile(file,sonarPoseOnRobot,priorCylinder);
    }
}

void surfaceGP::addPriorToSliceFile(const string& file,
                                    const CPose3D &sonarPoseOnRobot,
                                    const ellipticCylinder& priorCylinder)
{
    // Store the original lines
    vector<string> originalLines;
    ifstream f_original(file);
    if(f_original.is_open())
    {
        string line;
        // Ignore header
        getline(f_original,line);
        while(getline(f_original,line))
            originalLines.push_back(line);

        f_original.close();
    }

    // Modify the mean,low,high values by adding the r_prior
    CPose3D globalPoseSonar;
    ofstream f(file);
    if(f.is_open())
    {
        double s, yaw,mean,low,high;
        for(const string& line : originalLines)
        {
            stringstream ss(line);
            string val;

            // s
            getline(ss,val,',');
            s = stod(val);

            // yaw
            getline(ss,val,',');
            yaw = stod(val);

            // mean
            getline(ss,val,',');
            mean = stod(val);

            // low
            getline(ss,val,',');
            low = stod(val);

            // high
            getline(ss,val,',');
            high = stod(val);

            // Only plot slice in the simple trajectory along x axis
            const CPose3D robotPose(s, 0.,0.,0.,0.,0.);

            globalPoseSonar.composeFrom(/*refFrame_linearTraj + linearTrajPose*/ robotPose /*globalPoseRobot*/, sonarPoseOnRobot);
            double r_prior = surfaceValidationData::priorRange(priorCylinder, globalPoseSonar, yaw);

            f << s << ","
              << yaw << ","
              << mean + r_prior << ","
              << low + r_prior << ","
              << high + r_prior
              << "\n";
        }
        f.close();
    }
    else
        MRPT_LOG_ERROR_STREAM("[surfaceGP::addPriorToSliceFile] Can't open file " << file); 
}

